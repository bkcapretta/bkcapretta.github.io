
<!-- saved from url=(0061)http://www.cs.tufts.edu/comp/15/assignments/proj1/index.shtml -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Tufts:  Comp 15 Project 1</title>
  <link rel="stylesheet" type="text/css" href="./proj1_files/course.css">
</head>
<body>
<div id="topmatter">
  <div id="logo" onclick="document.location = &#39;../../index.html&#39;"></div>
  <div id="topcontent">
    <h1>Comp 15</h1>
    <h1>Project 1</h1>
  </div>
</div>
<div id="menubar">
  <a class="menu_item" href="http://www.cs.tufts.edu/comp/15/index.shtml">Home</a>
  <a class="menu_item" href="http://www.cs.tufts.edu/comp/15/calendar.shtml">Calendar</a>
  <a class="menu_item" href="http://www.cs.tufts.edu/comp/15/reference/index.shtml">Reference</a>
  <a class="menu_item" href="http://www.cs.tufts.edu/comp/15/admin.shtml">Administration</a>
</div>
<div id="maincontent" class="plain_text">

<h2>Project 1:  Simulation and Queues</h2>

For this project, we're going to do a <em>simulation.</em>  Computer
simulations are widely used for understanding phenomena and for making
real business decisions.  Google uses network simulation to determine
where in the world to put its servers.  Aircraft and automobile
companies use simulations to understand the aerodynamics of vehicles,
their behavior in various situations, and their crashworthiness.
Doing a simulation is much more economical than actually building a
real aircraft or putting in a huge data center and then finding out
you made a bad choice.
<p>
</p><h3>Nozama Online</h3>

For this project, you will simulate the operations of an order
processing facility for a top online retailer that we'll
call <em>Nozama Online.</em>  
<p>
The warehouse facility has two main functions: 
</p><ul>
  <li> Retrieving an order
  </li><li> Packaging an order 
</li></ul>
The warehouse has only one retrieval unit, and some
positive (nonzero) number of packaging units.  The reason for the
simulation is to determine which method should be used to assign orders
to packaging units: <code>FEWEST_ITEMS</code>, <code>SHORTEST_TIME</code>,
or <code>ROUND_ROBIN</code>.
<p></p>
<p>
  The <code>FEWEST_ITEMS</code> scheduler mode chooses a packaging unit to
  assign the next order to based on which packaging unit has fewest items in
  its queue.
  The <code>SHORTEST_TIME</code> scheduler mode chooses a packaging unit to
  assign the next order to based on which packaging unit has the "shortest
  total time". "Shortest total time" is defined by the sum of the "pack
  time remaining" of all orders in the queue.
  The <code>ROUND_ROBIN</code> scheduler mode chooses a packaging unit to
  assign the next order to based on "taking turns." For example, if there
  were 3 packaging units (PUs), the orders would go to PU1, then PU2, then
  PU3, then PU1, then PU2, ... etc.
</p>

<h3>Orders</h3>

The orders for Nozama have an arrival time, a fetch time, and a
pack time.  For this simulation we will only have one item per order;
future versions will manage multiple items in an order. An order's arrival
time is the number of minutes after the simulation started that the order
arrived. The fetch time is how long, in minutes, after the order arrival
time, it takes to find the item in the order and load it into one of the
packaging units. The pack time is how long the item will take to be packaged by
one of the packaging units. For this simulation, orders will never arrive
at the same time, and orders in the input file will be in order of arrival
time.  An order will have a total time in the system, this time is the
total number of minutes that have passed from the time the order arrived to
the time it finished being packaged. For tracking purposes, an order has an
order number â€” a unique id. An order looks like:
<pre>struct Order {
        int id;
        int arrival_timestamp;  /* aka "arrival time" */
        int fetch_duration;     /* aka "fetch time" */
        int pack_duration;      /* aka "pack time" */
        int fetch_time_left;
        int pack_time_left;
};
</pre>
The fields <code>fetch_time_left</code> and <code>pack_time_left</code> may help
you keep track of the order as it goes through the system, but are not strictly
necessary to use. You will get an input file containing the total number of
orders and detailing the orders placed over some time period. An example entry
would look like:
<pre>Order 123 arrived at time 0
fetch time 15 minutes, pack time 22 minutes

Order 127 arrived at time 12
fetch time 3 minutes, pack time 12 minutes
</pre>

<h3>Reading input</h3>
The user will run your program by running the command:
<pre>./proj1 &lt;filename&gt; &lt;num_packaging_units&gt; &lt;packer_mode&gt;</pre>

For example, the user may run:
<pre>./proj1 input.txt 4 ROUND_ROBIN</pre>

to run the simulation on orders detailed in input.txt using 4 packaging units
with a <code>ROUND_ROBIN</code> scheduling mode.<br><br>

We will provide you with code for parsing the input file into Order
structs given an input file name, which you may use if you like, and
which you are more than welcome to modify. However, you must read in
and parse these command line arguments yourself.  Resources that may
help you include
<a href="http://www.cplusplus.com/articles/DEN36Up4/" alt="command_line_args">
  using command line arguments
</a>.  You may also consult the code
in <code>read_from_file.cpp</code> that was given to use for HW 3.
<p>
To get an integer value from a string, you may use the provided code
in <code>string2int.h</code> and <code>string2int.cpp</code>.

</p><p>
You can get the files for the <code>Order</code> struct and the input
parsers from <code>/comp/15/files/proj1</code>.

</p><h3>Retrieval/Fetching</h3>

There is only one retrieval unit in this simulation.  (Your design
should consider how additional units may be added in the future.)  The
retrieval unit checks the list of orders that have arrived.  If an
order has arrived, the system then fetches that order.  The retrieval
unit can only retrieve one order from the warehouse shelves at a
time. When an order has been retrieved, the retrieval unit sends the
order to a packaging unit according to which assignment mode is being
used: <code>FEWEST_ITEMS</code>, <code>SHORTEST_TIME</code>, or
<code>ROUND_ROBIN</code>.

<h3>Packaging</h3> 

There is some number of packaging units in our warehouse, which is set
by the user at runtime. At any given time, a packaging unit can only be
working on one item.  A packaging unit may keep
track of the number of orders currently in the queue and the total time
needed to package all of the orders currently in the queue.  When an order
is packaged it leaves the warehouse.  At that time the elapsed time is set.
It is the difference between the current time and the time the order arrived.

<h3>Result File Format</h3>
To analyze the various packaging modes, you will create a file as follows
<p>
</p><pre>&lt;Order(0) arrival_timestamp = 0 fetch_duration = 10 pack_duration = 12 total_time = 22&gt;
&lt;Order(3) arrival_timestamp = 3 fetch_duration = 10 pack_duration = 20 total_time = 57&gt;
&lt;Order(1) arrival_timestamp = 1 fetch_duration = 10 pack_duration = 40 total_time = 59&gt;
...
&lt;Order(21) arrival_timestamp = 21 fetch_duration = 1 pack_duration = 20 total_time = 109&gt;
&lt;Order(25) arrival_timestamp = 25 fetch_duration = 1 pack_duration = 8 total_time = 113&gt;
min elapsed time 22 minutes
max elapsed time 113 minutes
mean elapsed time 74 minutes
28 orders processed
</pre>
<p>
</p><p>
Notice the elapsed time may be different for the three different packaging
unit assignment modes.  At the end of the file, you will have the min, max,
and mean data for the simulation.

</p><h3>Test Files</h3>

You should write many in-depth test cases to test each function you have
written, as well as to test the program overall. Be sure to identify and test
potential edge cases.

<p>
We will supply several sample input and output files.  We have given
you a couple input files, and we'll provide more data shortly.  The
sample data will be in <code>/comp/15/files/proj1/data</code>.

</p><h3>Part One Deliverables</h3>

For part one, you will turn in all of your header files for your
classes.  These headers files are allowed to change.  Namely, you may
change your design after the first deadline. In the header files you
should have detailed comments explaining your design.  These header
files and comments should describe what the class represents, the data
in the class, and the functions (public and private) in the class. In
addition to listing class definitions, describe how the classes
interact.  For example, does one class contain other classes as
members?  Does a class function take another object as an argument?
What kinds of connections can components have?  Instead of a data
structure and a call tree, design a set of classes and their
connections.  You should also include a <code>README</code> file. 
It is a text file listing the names of the header files included
in your submission.<br><br>

This submission will also contain your implementation of an
<code>Orderqueue</code> class: a queue that holds <code>Order</code>
structs. We recommend that you use the code you wrote for the queue lab
as a starting point for <code>Orderqueue.cpp</code>
<p>
The provide command is
</p><pre>provide comp15 proj1part1 Orderqueue.cpp ...all of your .h files...
</pre>

<h3>Part Two Deliverables</h3>

Part two will include all <code>.h</code> and <code>.cpp</code> files as well
as a <code>main.cpp</code> file. Your submission also must include a
<code>Makefile</code>, such that when we type <code>make</code>, your code
will compile. Additionally, your submission will include a <code>README</code>
file. The <code>README</code> will contain the following information:
<ol>
 <li>The title of the homework and the author's name (you)</li>
 <li>The purpose of the program</li>
 <li>Acknowledgements for any help you received</li>
 <li>The files that you provided and a short description of what 
    each file is and its purpose</li>
 <li>How to compile and run your program</li>
 <li>An outline of the data structures and algorithms that you used. 
    Given that this is a data structures class, you need to always 
    discuss the the data structure that you used and justify why 
    you used it.  For this assignment, there are a couple interesting
    algorthims you might describe, including the assignment modes.
</li>
</ol>
<p>
The provide command is
</p><pre>provide comp15 proj1part2 ...all of your files...
</pre>
<h3>Getting started</h3>
<p>
Please review the document about <a href="http://www.cs.tufts.edu/comp/15/assignments/proj1/planning/obj-plan2.pdf">project planning</a>!
</p>
<p>
Do not assume you can read this assignment one time.  You will want to
read and reread it.  Take notes.  Draw pictures.
</p>
<p>
Before writing any code, spend time thinking about how you
will solve the problem. Plan your solution carefully, keeping in mind
the pros and cons of each of the designs you consider. You shouldn't
start writing code until you've finished designing what each class will do
and how the classes will interact.  Draw pictures.
</p>
<p>
When you have an idea of what the pieces are and how they interact,
make a development plan.  What will you implement first?  Do things in
small step, and try to go from a simple working program (with testing)
to another simple working program.  Do not try to implement everything
at once!
</p>
<p>
To get the files:
</p><pre>mkdir proj1
cd proj1
cp -R /comp/15/files/proj1/* ./
</pre>
When we release more data files, you can get them
from <code>/comp/15/files/proj1/data</code>. 
<p></p>
</div>
<div id="dogtag">
   Mark A. Sheldon 
   (<a href="mailto:msheldon@cs.tufts.edu">msheldon@cs.tufts.edu</a>)<br>
      
      Last Modified 2016-Sep-30
</div> <!-- dogtag -->



</body></html>